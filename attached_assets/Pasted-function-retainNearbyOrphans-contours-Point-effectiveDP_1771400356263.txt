function retainNearbyOrphans(contours: Point[][], effectiveDPI: number): Point[][] {
  if (contours.length <= 1) return contours;

  const clamp = (v: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, v));

  const keepNearMainDistInches = 0.25;
  const keepNearMainDistPx = Math.max(8, Math.round(keepNearMainDistInches * effectiveDPI));

  // Expand main bounds to define the "design region" we should keep
  const baseExpandIn = Math.max(keepNearMainDistInches, 0.35); // 0.35" default
  const extraExpandIn = 0.15;                                  // extra safety
  const expandPx = Math.max(8, Math.round((baseExpandIn + extraExpandIn) * effectiveDPI));

  const boundsIntersect = (a: any, b: any) =>
    !(b.x1 < a.x0 || b.x0 > a.x1 || b.y1 < a.y0 || b.y0 > a.y1);

  const expandBounds = (b: any, padPx: number) => ({
    x0: b.x0 - padPx,
    y0: b.y0 - padPx,
    x1: b.x1 + padPx,
    y1: b.y1 + padPx
  });

  const withMeta = contours.map(c => ({
    points: c,
    bounds: computeBounds(c),
    area: Math.abs(computePolygonArea(c)) // ensure positive
  }));

  // Pick main by max area
  let mainIdx = 0;
  for (let i = 1; i < withMeta.length; i++) {
    if (withMeta[i].area > withMeta[mainIdx].area) mainIdx = i;
  }

  const main = withMeta[mainIdx];
  const mainBounds = main.bounds;
  const expandedMain = expandBounds(mainBounds, expandPx);

  // Dynamic speck filter (don’t drop small text islands, but drop dust)
  const relMin = Math.round(main.area * 0.0015);      // 0.15% of main
  const dynamicMinArea = Math.max(40, relMin);        // floor at 40px²

  // Optional safety cap: total extra kept area
  const maxExtraArea = Math.round(main.area * 0.65);  // allow +65% extra
  let extraAreaKept = 0;

  const kept: Point[][] = [main.points];

  for (let i = 0; i < withMeta.length; i++) {
    if (i === mainIdx) continue;

    const c = withMeta[i];

    // drop tiny dust
    if (c.area < dynamicMinArea) {
      console.log('[Worker] retainNearbyOrphans: discarding orphan', i,
        'area=', Math.round(c.area), 'px² (below dynamicMinArea=', dynamicMinArea, ')');
      continue;
    }

    // NEW RULE: keep if it intersects expanded design region OR is near by distance
    const ok =
      boundsIntersect(expandedMain, c.bounds) ||
      boundsWithinDistance(mainBounds, c.bounds, keepNearMainDistPx);

    if (!ok) {
      console.log('[Worker] retainNearbyOrphans: discarding orphan', i,
        'area=', Math.round(c.area), 'px² (too far + outside expanded region)');
      continue;
    }

    // Safety cap
    if (extraAreaKept + c.area > maxExtraArea) {
      console.log('[Worker] retainNearbyOrphans: discarding orphan', i,
        'area=', Math.round(c.area), 'px² (exceeds maxExtraArea cap)');
      continue;
    }

    console.log('[Worker] retainNearbyOrphans: keeping orphan', i,
      'area=', Math.round(c.area), 'px² (expandPx=', expandPx, ', keepDistPx=', keepNearMainDistPx, ')');

    kept.push(c.points);
    extraAreaKept += c.area;
  }

  console.log('[Worker] retainNearbyOrphans:',
    'total=', contours.length,
    'mainArea=', Math.round(main.area),
    'dynamicMinArea=', dynamicMinArea,
    'expandPx=', expandPx,
    'kept=', kept.length
  );

  return kept;
}
